#### 自增、自减

`++`、`--`，在自身的基础上`+1`或`减1`

```js
/* var a = 1;
//放在变量后面
a++;

console.log(a); */

var a = 1;
//放在变量前面
++a;

console.log(a);
```

通过上面的代码++可以放在操作按数的前面，也可以放在操作数的后面。

有啥区别呢：

* 放在操作数的前面时先加后用。

* 放在操作数的后面时先用后加。

  以上规则仅在`++`或`--`本行适用。



如果操作数不是数值则内部调用Number()工具进行转换，__会改变原变量的值和类型。__

```js
var a = true;
a++;
console.log(typeof a);//number

console.log(a);
```



#### 复合运算符

* `+=`，`a+=b`完全等价于`a = a +b`
* `-=`
* `*=`
* `/=`
* `%=`



#### 赋值运算符

`=`，将等号右边的值或表达式赋值给等号左边的变量。



左边肯定是一个容器（变量、对象属性），右边肯定是值或者是有值，可以求出来值的东西。





#### 比较运算符

比较后的结果应该是布尔值，true或false。

* `>`
* `<`
* `>=`，大于等于
* `<=`，小于等于

比较规则：

1. 如果两个操作数是数值，则执行的是数值比较。

   ```js
   var age1 = 18;
   var age2 = 17;
   
   console.log(age2 < age1);
   ```

2. 如果两个操作数都是字符串，则比较两个字符串对应的字符编码（不常用，知道一下）

   ```js
   var age1 = '234';
   var age2 = '123456789';
   
   console.log(age1 > age2);//true or false ?
   ```

   从第一个字符的编码开始比较，如果第一个字符的编码就能够比较出来大小，则后面的不比较。如果不能我就比较第二位，一直这样计算。如果一直到最后都没有比较出来，则位数多的大。

3. 其他类型的值比较调用`Number()`进行转换。

   ```js
   console.log(true > false);//true
   console.log(true > true);//false
   console.log(true  > 2);
   ```

4. 任何值和NaN比较最后结果都为false。

   ```js
   console.log(NaN > 1);
   console.log(NaN < 1);
   console.log(NaN > NaN);
   console.log(NaN < NaN);
   ```

   杀程序员祭天。

   `typeof abc`



#### 相等操作符

* 相等和不相等

  * `==`，等于。如果两个操作数相等，则返回true。
    * 类型相同的话直接比较他们的值是否相等。
    * 类型不同，只要有一个操作数是数值就先调用`Number()`
      * 基本数据类型number 、string、boolean和基本数据类型number、string、boolean比较都会先转换为数值。
    * null和undefined是相等的。
    * NaN和NaN不相等。
    * null==0 ，在做相等判断时null不进行转型。所以null和0是不同的类型，结果是false。
  * `!=`，不等于。如果两个操作数不相等，则返回true。

* 全等和不全等

  * `===`，全等于，两个操作数未经过转换就相等的情况下返回true。

    全等于：判断类型是否相等，如果相等判断值是否相等。如果第一个类型就不同那么必将是false。

#### 逻辑操作符

比较运算符只能比较两个值，如果我有多个条件就需要使用逻辑运算符将他们连接起来。



比如找崔旺找女朋友：有标准：女的、活的。

年龄 18~30。    年龄大于18  或者  年龄小于 30  



做活动   注册地 在上海 、广州  送礼物。   注册地===上海  或者   注册地 ===广州。



* 并且：`&&`，进行逻辑与的操作。第一个操作数和第二个操作数为true返回true，否则返回false。

  * 逻辑与操作符可以与任何类型的操作数进行比较而不仅仅是布尔值。如果第一个操作数经过Boolean转换后为false，那么返回第一个操作数（也就是说不只是返回的是布尔值类型的true或false）。
  * 如果第一个操作数经过Boolean()转换为true，那么将返回第二个操作数。
  * 并且的功能是什么：两个操作数都需要为true，我的结果才为true。第一个操作数是false了，没必要再进行向下执行了。如果第一个操作数是true，最终返回的是第二个操作数。
  * 逻辑与操作属于短路操作，如果第一个操作数能够决定结果，那么就不对第二个操作数进行求值。

* 或者，逻辑或操作符，第一个操作数或第二个操作数任意一个为true就返回true，否则返回false。

  * 逻辑或操作符可以使用任何类型的操作数而不仅仅是布尔值。如果第一个操作数经过Boolean()转换后true返回第一个操作数。如果第一个操作数经过Boolean()转换后为false，就返回第二个操作数。

  * 逻辑或也是短路操作。如果第一个操作数为true，就不会对第二个操作数求值了。

  * 我们可以利用短路操作来避免为变量赋值为null或undefiend。

    ```js
    var abc = '小美女';//undefined null
    
    var myObj = abc || '大帅哥!';
    
    console.log(myObj);//1
    ```

  我现在有一年份，给我判断出来是平年还是闰年，闰年为true，平年为false。

  1. 你要知道挖掘客户需求。  引导着客户。

  2. 4年一闰百年不闰，四百年一闰。

  3. 想办法转换为我们程序的逻辑语言。

     能够被4整除不能被100整除或者能够被400整除。

  4. 套用我们的语法。

* `!`，用来取得指定布尔值取反的结果（最终结果是布尔值）。

  如果变量的值不是布尔值，逻辑非操作符将会先把它的值转换为布尔值（`Boolean()`），然后再求反。

