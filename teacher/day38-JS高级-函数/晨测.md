### 9.9 晨测

- 使用 Object 的 toString 检测数据类型 举例说明，并说出返回值
  - `Object.prototype.toString.call(null)  [object Null]`
  - `Object.prototype.toString.call(undefined)  [object Undefined]`
  - `Object.prototype.toString.call(123)  [object Number]`
- 谈一谈 call apply bind
  - 每个函数都有这三个方法，这三个方法的作用一致，都是用来改变函数的上下文指向，其实就是改变函数中的`this`指向
  - `apply`同`call`和`bind`的参数不一样，`call`和`bind`的参数一样
    - `fn.apply(fn的this指向,[数组，里边书写的是fn的参数])`
    - `fn.call(fn的this指向,fn函数的参数 参数和参数之间逗号隔开)`
    - `fn.bind(fn的this指向,fn函数的参数 参数和参数之间逗号隔开)` 
  - `bind`只是改变了`this`的指向，并没有执行函数，`call`和`apply`改变了`this`指向并执行了函数
- 谈一谈显式原型
  - __每个函数__在创建的时候都会创建一个名叫`prototype`的属性，这个属性就是__原型属性__
  - 显示原型属性`prototype`是一个指针，指向的是当前函数的原型对象，默认是空对象
  - `prototype`属性只有在函数被构造调用时才生效，函数使用`new`调用的时候就是被构造调用了，也说成是一个构造函数
  - `prototype`属性的作用是:__由同一个构造函数生成的各个实例对象之间共享属性和方法__
- 谈一谈原型链
  - 所有的实例对象都有`__proto__`属性，它指向的就是原型对象
  - 这样通过`__proto__`属性就形成了一个链的结构-原型链
  - 当查找对象内部的属性/方法时，`js`引擎自动沿着这个原型链查找
  - 当给对象属性赋值时不会使用原型链，而只是在当前对象中进行操作
- 谈一谈`this`
  - `this`是函数的一个变量，它的指向是根据函数调用时确定的，`this`的绑定有5种方式
  - 自调用（默认绑定），自调用的this指向window
  - 对象调用（隐式绑定），指向上下文对象
  - 隐式丢失，指向window
  - 实例化调用，指向实例化对象
  - 显示绑定（硬绑定）指向call、apply、bind所规定的对象
- 画终极原型图
